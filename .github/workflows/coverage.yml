name: Coverage Analysis

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 0 * * 0' # Weekly on Sunday at midnight

env:
  NODE_VERSION: '20.x'

jobs:
  coverage-analysis:
    name: Analyze Coverage Trends
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for trend analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}

      - name: Install Dependencies
        run: npm ci

      - name: Run Full Test Suite with Coverage
        run: |
          npm run test:coverage -- \
            --json \
            --outputFile=coverage-data.json \
            --coverageReporters=json-summary \
            --coverageReporters=lcov \
            --coverageReporters=html

      - name: Analyze Coverage Trends
        id: coverage-trends
        run: |
          node -e "
            const fs = require('fs');
            const coverage = require('./coverage/coverage-summary.json');
            const totals = coverage.total;
            
            // Read previous coverage if exists
            let previousCoverage = null;
            try {
              previousCoverage = JSON.parse(fs.readFileSync('.coverage-baseline.json', 'utf8'));
            } catch (e) {
              console.log('No baseline coverage found');
            }
            
            // Calculate deltas
            const deltas = {};
            if (previousCoverage) {
              for (const metric of ['branches', 'functions', 'lines', 'statements']) {
                const current = totals[metric].pct;
                const previous = previousCoverage[metric];
                deltas[metric] = (current - previous).toFixed(2);
              }
            }
            
            // Save current as baseline for next run
            const baseline = {
              branches: totals.branches.pct,
              functions: totals.functions.pct,
              lines: totals.lines.pct,
              statements: totals.statements.pct,
              timestamp: new Date().toISOString()
            };
            
            fs.writeFileSync('.coverage-baseline.json', JSON.stringify(baseline, null, 2));
            
            // Output for GitHub Actions
            console.log('::set-output name=branches::' + totals.branches.pct.toFixed(2));
            console.log('::set-output name=functions::' + totals.functions.pct.toFixed(2));
            console.log('::set-output name=lines::' + totals.lines.pct.toFixed(2));
            console.log('::set-output name=statements::' + totals.statements.pct.toFixed(2));
            
            if (previousCoverage) {
              console.log('::set-output name=branches_delta::' + deltas.branches);
              console.log('::set-output name=functions_delta::' + deltas.functions);
              console.log('::set-output name=lines_delta::' + deltas.lines);
              console.log('::set-output name=statements_delta::' + deltas.statements);
            }
          "

      - name: Generate Coverage Badge
        run: |
          npm install -g badge-maker
          badge coverage "${{ steps.coverage-trends.outputs.lines }}%" \
            --color=$(node -e "
              const pct = ${{ steps.coverage-trends.outputs.lines }};
              if (pct >= 80) console.log('brightgreen');
              else if (pct >= 60) console.log('yellow');
              else if (pct >= 40) console.log('orange');
              else console.log('red');
            ") > coverage-badge.svg

      - name: Upload Coverage Badge
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: coverage-badge.svg

      - name: Find Uncovered Code
        run: |
          echo "# Uncovered Code Analysis" >> uncovered-report.md
          echo "" >> uncovered-report.md
          
          # Parse lcov.info to find uncovered lines
          node -e "
            const fs = require('fs');
            const lcov = fs.readFileSync('./coverage/lcov.info', 'utf8');
            const files = lcov.split('SF:');
            
            const uncovered = [];
            
            for (const file of files) {
              if (!file.trim()) continue;
              
              const lines = file.split('\\n');
              const filename = lines[0];
              const uncoveredLines = [];
              
              for (const line of lines) {
                if (line.startsWith('DA:')) {
                  const [lineNo, count] = line.substring(3).split(',');
                  if (count === '0') {
                    uncoveredLines.push(lineNo);
                  }
                }
              }
              
              if (uncoveredLines.length > 0) {
                uncovered.push({
                  file: filename,
                  lines: uncoveredLines
                });
              }
            }
            
            // Sort by number of uncovered lines
            uncovered.sort((a, b) => b.lines.length - a.lines.length);
            
            // Output top 10 files with most uncovered lines
            console.log('## Top 10 Files with Most Uncovered Lines\\n');
            for (let i = 0; i < Math.min(10, uncovered.length); i++) {
              const item = uncovered[i];
              console.log(\`### \${item.file}\`);
              console.log(\`Uncovered lines: \${item.lines.length}\`);
              console.log(\`Line numbers: \${item.lines.slice(0, 10).join(', ')}\${item.lines.length > 10 ? '...' : ''}\`);
              console.log('');
            }
          " >> uncovered-report.md

      - name: Upload Uncovered Report
        uses: actions/upload-artifact@v4
        with:
          name: uncovered-report
          path: uncovered-report.md

      - name: Comment PR with Coverage Trends
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const branches = '${{ steps.coverage-trends.outputs.branches }}';
            const functions = '${{ steps.coverage-trends.outputs.functions }}';
            const lines = '${{ steps.coverage-trends.outputs.lines }}';
            const statements = '${{ steps.coverage-trends.outputs.statements }}';
            
            const branchesDelta = '${{ steps.coverage-trends.outputs.branches_delta }}';
            const functionsDelta = '${{ steps.coverage-trends.outputs.functions_delta }}';
            const linesDelta = '${{ steps.coverage-trends.outputs.lines_delta }}';
            const statementsDelta = '${{ steps.coverage-trends.outputs.statements_delta }}';
            
            const formatDelta = (delta) => {
              if (!delta) return '';
              const num = parseFloat(delta);
              if (num > 0) return `ðŸ“ˆ +${delta}%`;
              if (num < 0) return `ðŸ“‰ ${delta}%`;
              return 'â†’ 0%';
            };
            
            const comment = `## Coverage Report
            
            | Metric | Coverage | Change |
            |--------|----------|--------|
            | Branches | ${branches}% | ${formatDelta(branchesDelta)} |
            | Functions | ${functions}% | ${formatDelta(functionsDelta)} |
            | Lines | ${lines}% | ${formatDelta(linesDelta)} |
            | Statements | ${statements}% | ${formatDelta(statementsDelta)} |
            
            ðŸ“Š [View Full Report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;
            
            // Find and update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## Coverage Report')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Store Coverage History
        if: github.ref == 'refs/heads/main'
        run: |
          # Create coverage history file
          echo "{
            \"commit\": \"${{ github.sha }}\",
            \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
            \"branches\": ${{ steps.coverage-trends.outputs.branches }},
            \"functions\": ${{ steps.coverage-trends.outputs.functions }},
            \"lines\": ${{ steps.coverage-trends.outputs.lines }},
            \"statements\": ${{ steps.coverage-trends.outputs.statements }}
          }" >> coverage-history.jsonl

      - name: Upload Coverage History
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-history
          path: coverage-history.jsonl

  coverage-gates:
    name: Coverage Quality Gates
    needs: coverage-analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Check Coverage Requirements
        run: |
          # Define minimum coverage requirements
          MIN_COVERAGE=50
          MIN_DELTA=-5 # Maximum allowed decrease
          
          # This would normally check the coverage values from the previous job
          # For now, we'll just echo the requirements
          echo "Minimum coverage required: ${MIN_COVERAGE}%"
          echo "Maximum coverage decrease allowed: ${MIN_DELTA}%"
          
          # In a real scenario, you would fail if coverage doesn't meet requirements
          # if [[ $COVERAGE -lt $MIN_COVERAGE ]]; then
          #   echo "Coverage is below minimum requirement"
          #   exit 1
          # fi